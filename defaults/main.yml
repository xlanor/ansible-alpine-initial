---
# defaults file for ansible-initial-server

iserver_is_a_vm: True
### SUDOERS ###
# use the name of the default user which was used during installation
# this Ansible role is not intended to add or change a default user
iserver_user: deploy
iserver_become: sudo ## do not chanage this (use doas for OpenBSD) ##
iserver_kickstart_become: "{{ iserver_become }}"
iserver_lock_root: False

### BASE PACKAGES ###

iserver_alpine_repos:
  - 'http://download.nus.edu.sg/mirror/alpine/v3.12/main'
  - 'http://download.nus.edu.sg/mirror/alpine/v3.12/community'
  - '@edge http://download.nus.edu.sg/mirror/alpine/edge/main'
  - '@testing http://download.nus.edu.sg/mirror/alpine/edge/testing'
  - '@edgecommunity http://download.nus.edu.sg/mirror/alpine/edge/community'


# packages to install on every Alpine server
iserver_alpine_packages:
  - openssh # needed for Travis testing
  - vim
  - qemu-guest-agent@edgecommunity # needed by packer
  - sudo    # required
  - shadow  # required for adduser with Ansible
  - nano    # set as default editor in .profile
  - pstree
  - wget
  - curl

### NETWORKING ###
iserver_hostname: iserver-kvm
iserver_domain: unassigned.domain
iserver_fqdn: "{{ iserver_hostname }}.{{ iserver_domain }}"

iserver_interface: ens18
iserver_obsd_interface: vio0
iserver_static_ip: false
# Add here main IP of the host
iserver_host_main_ip: 127.1.1.1
# This IP will go into 'hosts'
# - use a localhost IP for a template with DHCP
# - or use a fixed routed external IP for servers
# - which will also go into and 'interfaces' or 'netplan'
iserver_ip: 127.0.1.1
# use slash notation /24 for 255.255.255.0 or /32 for 255.255.255.255
iserver_netmask: "/32"
iserver_nameservers: 192.168.1.30,1.1.1.1

### SSH ###
iserver_ssh_port: 22
# this picks up the dafault public key from the user
iserver_sshkey: "{{ lookup('file', lookup('env','HOME') + '/.ssh/id_rsa.pub') }}"
iserver_ssh_banner: none # or /etc/ssh/issue.net

### CUSTOMIZE ###
iserver_timezone: Asia/Singapore

# Alpine profiles
iserver_alpine_root_profile: |
  export PS1="\[\033[1;31m\][\u@\h:\w]#\[\033[0m\] "
  export LS_OPTIONS='--color=auto'
  eval "`dircolors`"
  alias ls='ls $LS_OPTIONS'
  export EDITOR=/usr/bin/vim

iserver_alpine_user_profile: |
  export PS1="\[\033[1;34m\][\u@\h:\w]$\[\033[0m\] "
  export LS_OPTIONS='--color=auto'
  eval "`dircolors`"
  alias ls='ls $LS_OPTIONS'
  export EDITOR=/usr/bin/vim

# motd
iserver_motd_welcome: |
  #!/bin/sh
  ## OS/ENVIRONMENT INFO DETECTION
  if command -v getprop > /dev/null; then
    linuxtype=android
    host="$(getprop net.hostname)"
  else
    . /etc/os-release
    host="$(cat /proc/sys/kernel/hostname)"
    linuxtype=none
  fi
  ostype="$(uname)"
  kernel="$(echo $(uname -r) | cut -d'-' -f1-2)"
  case $ostype in
    "Linux"*)
      if [ -f /bedrock/etc/bedrock-release ]; then
        os="$(brl version)"
      elif [ $linuxtype = android ]; then
        os="Android $(getprop ro.build.version.release)"
      else
        os="${PRETTY_NAME}"
      fi
      shell=${SHELL##*/};;
    "Darwin"*)
      while IFS='<>' read -r _ _ line _; do
        case $line in
          ProductVersion)
            IFS='<>' read -r _ _ mac_version _
            break;;
        esac
      done < /System/Library/CoreServices/SystemVersion.plist
      os="macOS ${mac_version}";;
    *) os="Idk"
  esac

  ## PACKAGE MANAGER AND PACKAGES DETECTION

  manager=$(which nix-env yum zypper dnf rpm apt brew port pacman xbps-query pkg emerge cave apk kiss pmm /usr/sbin/slackpkg yay cpm eopkg 2>/dev/null)
  manager=${manager##*/}
  case $manager in
    cpm) packages="$(cpm C)";;
    brew) packages="$(brew list --formula | wc -l)";;
    port) packages=$(port installed | tot);;
    apt) packages="$(dpkg-query -f '${binary:Package}\n' -W | wc -l)";;
    rpm) packages="$(rpm -qa --last| wc -l)";;
    yum) packages="$(yum list installed | wc -l)";;
    dnf) packages="$(dnf list installed | wc -l)";;
    zypper) packages="$(zypper se | wc -l)";;
    pacman) packages="$(pacman -Q | wc -l)";;
    yay) packages="$(yay -Q | wc -l)";;
    kiss) packages="$(kiss list | wc -l)";;
    pkg|emerge) packages="$(qlist -I | wc -l)";;
    cave) packages="$(cave show installed-slots | wc -l)";;
    xbps-query) packages="$(xbps-query -l | wc -l)";;
    nix-env) packages="$(nix-store -q --requisites /run/current-system/sw | wc -l)";;
    apk) packages="$(apk list --installed | wc -l)";;
    pmm) packages="$(/bedrock/libexec/pmm pacman pmm -Q 2>/dev/null | wc -l )";;
    eopkg) packages="$(eopkg li | wc -l)";;
    /usr/sbin/slackpkg) packages="$(ls /var/log/packages | wc -l)";;
    *)
      packages="$(ls /usr/bin | wc -l)"
      manager="/usr/bin";;
  esac

  ## UPTIME DETECTION

  case $ostype in
    "Linux")
      IFS=. read -r s _ < /proc/uptime;;
    *) 
      s=$(sysctl -n kern.boottime)
      s=${s#*=}
      s=${s%,*}
      s=$(($(date +%s) - s));;
  esac
  d="$((s / 60 / 60 / 24))"
  h="$((s / 60 / 60 % 24))"
  m="$((s / 60 % 60))"
  # Plurals
  [ "$d" -gt 1 ] && dp=s
  [ "$h" -gt 1 ] && hp=s
  [ "$m" -gt 1 ] && mp=s
  # Hide empty fields.
  [ "$d" = 0 ] && d=
  [ "$h" = 0 ] && h=
  [ "$m" = 0 ] && m=
  # Make the output of uptime smaller.
  case $uptime_shorthand in
    tiny)
      [ "$d" ] && uptime="${d}d, "
      [ "$h" ] && uptime="$uptime${h}h, "
      [ "$m" ] && uptime="$uptime${m}m"
      uptime=${uptime%, };;
    *)
      [ "$d" ] && uptime="$d day$dp, "
      [ "$h" ] && uptime="$uptime$h hour$hp, "
      [ "$m" ] && uptime="$uptime$m min$mp"
      uptime=${uptime%, };;
  esac

  ## RAM DETECTION

  case $ostype in
    "Linux")
      while IFS=':k '  read -r key val _; do
        case $key in
          MemTotal)
            mem_used=$((mem_used + val))
            mem_full=$val;;
          Shmem) mem_used=$((mem_used + val));;
          MemFree|Buffers|Cached|SReclaimable) mem_used=$((mem_used - val));;
        esac
      done < /proc/meminfo
      mem_used=$((mem_used / 1024)) 
      mem_full=$((mem_full / 1024));;
    "Darwin"*)
      mem_full=$(($(sysctl -n hw.memsize) / 1024 / 1024))
      while IFS=:. read -r key val; do
        case $key in
          *' wired'*|*' active'*|*' occupied'*)
            mem_used=$((mem_used + ${val:-0}));;
        esac
        done <<-EOF
          $(vm_stat)
              EOF

        mem_used=$((mem_used * 4 / 1024));;
    *)
      mem_full="idk"
      mem_used="idk"
  esac
  memstat="${mem_used}/${mem_full} MB"
  if which dc > /dev/null 2>&1; then
    mempercent="($(echo 100 ${mem_used} \* ${mem_full} / p | dc)%)"
  fi
  ## DEFINE COLORS

  bold='[1m'
  black='[30m'
  red='[31m'
  green='[32m'
  yellow='[33m'
  blue='[34m'
  magenta='[35m'
  cyan='[36m'
  white='[37m'
  grey='[90m'
  reset='[0m'

  ## USER VARIABLES -- YOU CAN CHANGE THESE

  lc="${reset}${bold}${magenta}"  # labels
  nc="${reset}${bold}${yellow}"   # user
  hn="${reset}${bold}${blue}"     # hostname
  ic="${reset}${green}"           # info
  c0="${reset}${grey}"            # first color
  c1="${reset}${white}"           # second color
  c2="${reset}${yellow}"          # third color

  ## OUTPUT

  cat <<EOF

  ${c0}      ___     ${nc}${USER}${red}@${reset}${hn}${host}${reset} 
  ${c0}     (${c1}.. ${c0}\    ${lc}ï…¼  ${ic}${os}${reset}
  ${c0}     (${c2}<> ${c0}|    ${lc}îˆº  ${ic}${kernel}${reset}
  ${c0}    /${c1}/  \\ ${c0}\\   ${lc}ï¡š  ${ic}${RAM}${memstat} ${mempercent}
  ${c0}   ( ${c1}|  | ${c0}/|  ${lc}ï£“  ${ic}${packages} (${manager})${reset}
  ${c2}  _${c0}/\\ ${c1}__)${c0}/${c2}_${c0})  ${lc}ï™µ  ${ic}${uptime}${reset}
  ${c2}  \/${c0}-____${c2}\/${reset}   ${lc}îˆ«  ${red}â–ˆâ–ˆâ–ˆ${green}â–ˆâ–ˆâ–ˆ${yellow}â–ˆâ–ˆâ–ˆ${blue}â–ˆâ–ˆâ–ˆ${magenta}â–ˆâ–ˆâ–ˆ${cyan}â–ˆâ–ˆâ–ˆ${reset}
  EOF

# name of disk to show available space on login
iserver_main_disk: sda1

# needs 'verse' installed
iserver_verse_enabled: False
